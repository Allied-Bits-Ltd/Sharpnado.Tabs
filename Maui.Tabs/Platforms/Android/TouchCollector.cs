//
// https://github.com/mrxten/XamEffects/blob/master/src/XamEffects.Droid/GestureCollectors/TouchCollector.cs
//
// ec1641f on 25 May 2019
//
// This will exclude this file from stylecop analysis
// <auto-generated/>

using Android.OS;
using Android.Views;

using View = Android.Views.View;

namespace Sharpnado.Tabs.Effects.Droid.GestureCollectors;

internal enum ActionType
{
    Ripple = 0,

    Tap = 1
}

internal record ActionSource(ActionType ActionType, Action<View.TouchEventArgs> Action);

internal static class TouchCollector
{
    private const string Tag = "CommandEffectAndroid";

    private static View _activeView;

    private static Dictionary<View, List<ActionSource>> Collection { get; } = new();

    public static void Add(View view, Action<View.TouchEventArgs> action, ActionType actionType)
    {
        if (!Collection.ContainsKey(view))
        {
            view.Touch += ActionActivator;
            Collection.Add(view, []);
        }

        Collection[view]
            .Add(new ActionSource(actionType, action));

        InternalLogger.Debug(Tag, () => $"Add {actionType}: {Collection[view].Count} actions");
    }

    public static void Delete(View view, Action<View.TouchEventArgs> action, ActionType actionType)
    {
        if (!Collection.ContainsKey(view))
        {
            return;
        }

        var actions = Collection[view];
        actions.Remove(new ActionSource(actionType, action));

        if (actions.Count > 0)
        {
            InternalLogger.Debug(Tag, () => $"Delete {actionType}: {Collection[view].Count} actions");
            return;
        }

        view.Touch -= ActionActivator;
        Collection.Remove(view);

        InternalLogger.Debug(Tag, () => $"Delete {actionType}: view removed!");
    }

    private static void ActionActivator(object sender, View.TouchEventArgs e)
    {
        var view = (View)sender;
        if (!Collection.ContainsKey(view) || (_activeView != null && _activeView != view))
        {
            return;
        }

        var actions = Collection[view]
            .ToArray();

        var rippleActions = actions.Where(source => source.ActionType == ActionType.Ripple).ToList();
        bool hasRipple = rippleActions.Any();

        using var handler = new Handler(Looper.MainLooper);

        handler.PostAtFrontOfQueue(
            () =>
            {
                switch (e.Event.Action)
                {
                    case MotionEventActions.Down:
                        _activeView = view;
                        view.PlaySoundEffect(SoundEffects.Click);
                        break;

                    case MotionEventActions.Up:
                    case MotionEventActions.Cancel:
                        _activeView = null;
                        e.Handled = true;
                        break;
                }
            });

        handler.Post(
            () =>
            {
                foreach (var valueAction in rippleActions)
                {
                    valueAction?.Action.Invoke(e);
                }
            });

        handler.PostDelayed(
            () =>
            {
                foreach (var valueAction in actions.Where(source => source.ActionType == ActionType.Tap))
                {
                    valueAction?.Action.Invoke(e);
                }
            },
            hasRipple ? 100 : 0);
    }
}